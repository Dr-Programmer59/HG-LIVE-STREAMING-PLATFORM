"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/awaitqueue";
exports.ids = ["vendor-chunks/awaitqueue"];
exports.modules = {

/***/ "(ssr)/./node_modules/awaitqueue/lib/Logger.js":
/*!***********************************************!*\
  !*** ./node_modules/awaitqueue/lib/Logger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nconst LIB_NAME = 'awaitqueue';\nclass Logger {\n    constructor(prefix) {\n        if (prefix) {\n            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);\n        }\n        else {\n            this._debug = (0, debug_1.default)(LIB_NAME);\n            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);\n            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);\n        }\n        /* eslint-disable no-console */\n        this._debug.log = console.info.bind(console);\n        this._warn.log = console.warn.bind(console);\n        this._error.log = console.error.bind(console);\n        /* eslint-enable no-console */\n    }\n    get debug() {\n        return this._debug;\n    }\n    get warn() {\n        return this._warn;\n    }\n    get error() {\n        return this._error;\n    }\n}\nexports.Logger = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvTG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLEdBQUcsT0FBTztBQUNyRSxpREFBaUQsU0FBUyxRQUFRLE9BQU87QUFDekUsa0RBQWtELFNBQVMsU0FBUyxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFELGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGctbGl2ZS8uL25vZGVfbW9kdWxlcy9hd2FpdHF1ZXVlL2xpYi9Mb2dnZXIuanM/MWNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IExJQl9OQU1FID0gJ2F3YWl0cXVldWUnO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtMSUJfTkFNRX06JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TElCX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoTElCX05BTUUpO1xuICAgICAgICAgICAgdGhpcy5fd2FybiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpXQVJOYCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke0xJQl9OQU1FfTpFUlJPUmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX3dhcm4ubG9nID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICAgIHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnO1xuICAgIH1cbiAgICBnZXQgd2FybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm47XG4gICAgfVxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/awaitqueue/lib/Logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"(ssr)/./node_modules/awaitqueue/lib/Logger.js\");\nconst logger = new Logger_1.Logger();\n/**\n * Custom Error derived class used to reject pending tasks once stop() method\n * has been called.\n */\nclass AwaitQueueStoppedError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue stopped');\n        this.name = 'AwaitQueueStoppedError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueStoppedError);\n        }\n    }\n}\nexports.AwaitQueueStoppedError = AwaitQueueStoppedError;\n/**\n * Custom Error derived class used to reject pending tasks once removeTask()\n * method has been called.\n */\nclass AwaitQueueRemovedTaskError extends Error {\n    constructor(message) {\n        super(message ?? 'AwaitQueue task removed');\n        this.name = 'AwaitQueueRemovedTaskError';\n        // @ts-ignore\n        if (typeof Error.captureStackTrace === 'function') {\n            // @ts-ignore\n            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);\n        }\n    }\n}\nexports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;\nclass AwaitQueue {\n    constructor() {\n        // Queue of pending tasks (map of PendingTasks indexed by id).\n        this.pendingTasks = new Map();\n        // Incrementing PendingTask id.\n        this.nextTaskId = 0;\n        // Whether stop() method is stopping all pending tasks.\n        this.stopping = false;\n    }\n    get size() {\n        return this.pendingTasks.size;\n    }\n    async push(task, name) {\n        name = name ?? task.name;\n        logger.debug(`push() [name:${name}]`);\n        if (typeof task !== 'function') {\n            throw new TypeError('given task is not a function');\n        }\n        if (name) {\n            try {\n                Object.defineProperty(task, 'name', { value: name });\n            }\n            catch (error) { }\n        }\n        return new Promise((resolve, reject) => {\n            const pendingTask = {\n                id: this.nextTaskId++,\n                task: task,\n                name: name,\n                enqueuedAt: Date.now(),\n                executedAt: undefined,\n                completed: false,\n                resolve: (result) => {\n                    // pendingTask.resolve() can only be called in execute() method. Since\n                    // resolve() was called it means that the task successfully completed.\n                    // However the task may have been stopped before it completed (via\n                    // stop() or remove()) so its completed flag was already set. If this\n                    // is the case, abort here since next task (if any) is already being\n                    // executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`resolving task [name:${pendingTask.name}]`);\n                    // Resolve the task with the obtained result.\n                    resolve(result);\n                    // Execute the next pending task (if any).\n                    const [nextPendingTask] = this.pendingTasks.values();\n                    // NOTE: During the resolve() callback the user app may have interacted\n                    // with the queue. For instance, the app may have pushed a task while\n                    // the queue was empty so such a task is already being executed. If so,\n                    // don't execute it twice.\n                    if (nextPendingTask && !nextPendingTask.executedAt) {\n                        void this.execute(nextPendingTask);\n                    }\n                },\n                reject: (error) => {\n                    // pendingTask.reject() can be called within execute() method if the\n                    // task completed with error. However it may have also been called in\n                    // stop() or remove() methods (before or while being executed) so its\n                    // completed flag was already set. If so, abort here since next task\n                    // (if any) is already being executed.\n                    if (pendingTask.completed) {\n                        return;\n                    }\n                    pendingTask.completed = true;\n                    // Remove the task from the queue.\n                    this.pendingTasks.delete(pendingTask.id);\n                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));\n                    // Reject the task with the obtained error.\n                    reject(error);\n                    // Execute the next pending task (if any) unless stop() is running.\n                    if (!this.stopping) {\n                        const [nextPendingTask] = this.pendingTasks.values();\n                        // NOTE: During the reject() callback the user app may have interacted\n                        // with the queue. For instance, the app may have pushed a task while\n                        // the queue was empty so such a task is already being executed. If so,\n                        // don't execute it twice.\n                        if (nextPendingTask && !nextPendingTask.executedAt) {\n                            void this.execute(nextPendingTask);\n                        }\n                    }\n                }\n            };\n            // Append task to the queue.\n            this.pendingTasks.set(pendingTask.id, pendingTask);\n            // And execute it if this is the only task in the queue.\n            if (this.pendingTasks.size === 1) {\n                void this.execute(pendingTask);\n            }\n        });\n    }\n    stop() {\n        logger.debug('stop()');\n        this.stopping = true;\n        for (const pendingTask of this.pendingTasks.values()) {\n            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);\n            pendingTask.reject(new AwaitQueueStoppedError());\n        }\n        this.stopping = false;\n    }\n    remove(taskIdx) {\n        logger.debug(`remove() [taskIdx:${taskIdx}]`);\n        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];\n        if (!pendingTask) {\n            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);\n            return;\n        }\n        pendingTask.reject(new AwaitQueueRemovedTaskError());\n    }\n    dump() {\n        const now = Date.now();\n        let idx = 0;\n        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({\n            idx: idx++,\n            task: pendingTask.task,\n            name: pendingTask.name,\n            enqueuedTime: pendingTask.executedAt\n                ? pendingTask.executedAt - pendingTask.enqueuedAt\n                : now - pendingTask.enqueuedAt,\n            executionTime: pendingTask.executedAt\n                ? now - pendingTask.executedAt\n                : 0\n        }));\n    }\n    async execute(pendingTask) {\n        logger.debug(`execute() [name:${pendingTask.name}]`);\n        if (pendingTask.executedAt) {\n            throw new Error('task already being executed');\n        }\n        pendingTask.executedAt = Date.now();\n        try {\n            const result = await pendingTask.task();\n            // Resolve the task with its resolved result (if any).\n            pendingTask.resolve(result);\n        }\n        catch (error) {\n            // Reject the task with its rejected error.\n            pendingTask.reject(error);\n        }\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdhaXRxdWV1ZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0NBQWtDLEdBQUcsOEJBQThCO0FBQ3hGLGlCQUFpQixtQkFBTyxDQUFDLCtEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGctbGl2ZS8uL25vZGVfbW9kdWxlcy9hd2FpdHF1ZXVlL2xpYi9pbmRleC5qcz8yNWFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bd2FpdFF1ZXVlID0gZXhwb3J0cy5Bd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvciA9IGV4cG9ydHMuQXdhaXRRdWV1ZVN0b3BwZWRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcigpO1xuLyoqXG4gKiBDdXN0b20gRXJyb3IgZGVyaXZlZCBjbGFzcyB1c2VkIHRvIHJlamVjdCBwZW5kaW5nIHRhc2tzIG9uY2Ugc3RvcCgpIG1ldGhvZFxuICogaGFzIGJlZW4gY2FsbGVkLlxuICovXG5jbGFzcyBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnQXdhaXRRdWV1ZSBzdG9wcGVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBd2FpdFF1ZXVlU3RvcHBlZEVycm9yJztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBd2FpdFF1ZXVlU3RvcHBlZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXdhaXRRdWV1ZVN0b3BwZWRFcnJvciA9IEF3YWl0UXVldWVTdG9wcGVkRXJyb3I7XG4vKipcbiAqIEN1c3RvbSBFcnJvciBkZXJpdmVkIGNsYXNzIHVzZWQgdG8gcmVqZWN0IHBlbmRpbmcgdGFza3Mgb25jZSByZW1vdmVUYXNrKClcbiAqIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQuXG4gKi9cbmNsYXNzIEF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnQXdhaXRRdWV1ZSB0YXNrIHJlbW92ZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yJztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBd2FpdFF1ZXVlUmVtb3ZlZFRhc2tFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWVSZW1vdmVkVGFza0Vycm9yID0gQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3I7XG5jbGFzcyBBd2FpdFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gUXVldWUgb2YgcGVuZGluZyB0YXNrcyAobWFwIG9mIFBlbmRpbmdUYXNrcyBpbmRleGVkIGJ5IGlkKS5cbiAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEluY3JlbWVudGluZyBQZW5kaW5nVGFzayBpZC5cbiAgICAgICAgdGhpcy5uZXh0VGFza0lkID0gMDtcbiAgICAgICAgLy8gV2hldGhlciBzdG9wKCkgbWV0aG9kIGlzIHN0b3BwaW5nIGFsbCBwZW5kaW5nIHRhc2tzLlxuICAgICAgICB0aGlzLnN0b3BwaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nVGFza3Muc2l6ZTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaCh0YXNrLCBuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lID8/IHRhc2submFtZTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBwdXNoKCkgW25hbWU6JHtuYW1lfV1gKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnaXZlbiB0YXNrIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhc2ssICduYW1lJywgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUYXNrID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm5leHRUYXNrSWQrKyxcbiAgICAgICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZW5xdWV1ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBleGVjdXRlZEF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlbmRpbmdUYXNrLnJlc29sdmUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW4gZXhlY3V0ZSgpIG1ldGhvZC4gU2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSgpIHdhcyBjYWxsZWQgaXQgbWVhbnMgdGhhdCB0aGUgdGFzayBzdWNjZXNzZnVsbHkgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyIHRoZSB0YXNrIG1heSBoYXZlIGJlZW4gc3RvcHBlZCBiZWZvcmUgaXQgY29tcGxldGVkICh2aWFcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCgpIG9yIHJlbW92ZSgpKSBzbyBpdHMgY29tcGxldGVkIGZsYWcgd2FzIGFscmVhZHkgc2V0LiBJZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBjYXNlLCBhYm9ydCBoZXJlIHNpbmNlIG5leHQgdGFzayAoaWYgYW55KSBpcyBhbHJlYWR5IGJlaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1Rhc2suY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2suY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YXNrIGZyb20gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUocGVuZGluZ1Rhc2suaWQpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYHJlc29sdmluZyB0YXNrIFtuYW1lOiR7cGVuZGluZ1Rhc2submFtZX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHRhc2sgd2l0aCB0aGUgb2J0YWluZWQgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIG5leHQgcGVuZGluZyB0YXNrIChpZiBhbnkpLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbmV4dFBlbmRpbmdUYXNrXSA9IHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBEdXJpbmcgdGhlIHJlc29sdmUoKSBjYWxsYmFjayB0aGUgdXNlciBhcHAgbWF5IGhhdmUgaW50ZXJhY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBxdWV1ZS4gRm9yIGluc3RhbmNlLCB0aGUgYXBwIG1heSBoYXZlIHB1c2hlZCBhIHRhc2sgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHF1ZXVlIHdhcyBlbXB0eSBzbyBzdWNoIGEgdGFzayBpcyBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkLiBJZiBzbyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSBpdCB0d2ljZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQZW5kaW5nVGFzayAmJiAhbmV4dFBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5leGVjdXRlKG5leHRQZW5kaW5nVGFzayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlbmRpbmdUYXNrLnJlamVjdCgpIGNhbiBiZSBjYWxsZWQgd2l0aGluIGV4ZWN1dGUoKSBtZXRob2QgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhc2sgY29tcGxldGVkIHdpdGggZXJyb3IuIEhvd2V2ZXIgaXQgbWF5IGhhdmUgYWxzbyBiZWVuIGNhbGxlZCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wKCkgb3IgcmVtb3ZlKCkgbWV0aG9kcyAoYmVmb3JlIG9yIHdoaWxlIGJlaW5nIGV4ZWN1dGVkKSBzbyBpdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVkIGZsYWcgd2FzIGFscmVhZHkgc2V0LiBJZiBzbywgYWJvcnQgaGVyZSBzaW5jZSBuZXh0IHRhc2tcbiAgICAgICAgICAgICAgICAgICAgLy8gKGlmIGFueSkgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUYXNrLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUYXNrLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGFzayBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHBlbmRpbmdUYXNrLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGByZWplY3RpbmcgdGFzayBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XTogJXNgLCBTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IHRoZSB0YXNrIHdpdGggdGhlIG9idGFpbmVkIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBuZXh0IHBlbmRpbmcgdGFzayAoaWYgYW55KSB1bmxlc3Mgc3RvcCgpIGlzIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdG9wcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW25leHRQZW5kaW5nVGFza10gPSB0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IER1cmluZyB0aGUgcmVqZWN0KCkgY2FsbGJhY2sgdGhlIHVzZXIgYXBwIG1heSBoYXZlIGludGVyYWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIHF1ZXVlLiBGb3IgaW5zdGFuY2UsIHRoZSBhcHAgbWF5IGhhdmUgcHVzaGVkIGEgdGFzayB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHF1ZXVlIHdhcyBlbXB0eSBzbyBzdWNoIGEgdGFzayBpcyBhbHJlYWR5IGJlaW5nIGV4ZWN1dGVkLiBJZiBzbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgaXQgdHdpY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBlbmRpbmdUYXNrICYmICFuZXh0UGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5leGVjdXRlKG5leHRQZW5kaW5nVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQXBwZW5kIHRhc2sgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHBlbmRpbmdUYXNrLmlkLCBwZW5kaW5nVGFzayk7XG4gICAgICAgICAgICAvLyBBbmQgZXhlY3V0ZSBpdCBpZiB0aGlzIGlzIHRoZSBvbmx5IHRhc2sgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rhc2tzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZXhlY3V0ZShwZW5kaW5nVGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3AoKScpO1xuICAgICAgICB0aGlzLnN0b3BwaW5nID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwZW5kaW5nVGFzayBvZiB0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBzdG9wKCkgfCBzdG9wcGluZyB0YXNrIFtuYW1lOiR7cGVuZGluZ1Rhc2submFtZX1dYCk7XG4gICAgICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QobmV3IEF3YWl0UXVldWVTdG9wcGVkRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZW1vdmUodGFza0lkeCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYHJlbW92ZSgpIFt0YXNrSWR4OiR7dGFza0lkeH1dYCk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdUYXNrID0gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKSlbdGFza0lkeF07XG4gICAgICAgIGlmICghcGVuZGluZ1Rhc2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zyhgc3RvcCgpIHwgbm8gdGFzayB3aXRoIGdpdmVuIGlkeCBbdGFza0lkeDoke3Rhc2tJZHh9XWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChuZXcgQXdhaXRRdWV1ZVJlbW92ZWRUYXNrRXJyb3IoKSk7XG4gICAgfVxuICAgIGR1bXAoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKSkubWFwKChwZW5kaW5nVGFzaykgPT4gKHtcbiAgICAgICAgICAgIGlkeDogaWR4KyssXG4gICAgICAgICAgICB0YXNrOiBwZW5kaW5nVGFzay50YXNrLFxuICAgICAgICAgICAgbmFtZTogcGVuZGluZ1Rhc2submFtZSxcbiAgICAgICAgICAgIGVucXVldWVkVGltZTogcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdFxuICAgICAgICAgICAgICAgID8gcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCAtIHBlbmRpbmdUYXNrLmVucXVldWVkQXRcbiAgICAgICAgICAgICAgICA6IG5vdyAtIHBlbmRpbmdUYXNrLmVucXVldWVkQXQsXG4gICAgICAgICAgICBleGVjdXRpb25UaW1lOiBwZW5kaW5nVGFzay5leGVjdXRlZEF0XG4gICAgICAgICAgICAgICAgPyBub3cgLSBwZW5kaW5nVGFzay5leGVjdXRlZEF0XG4gICAgICAgICAgICAgICAgOiAwXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShwZW5kaW5nVGFzaykge1xuICAgICAgICBsb2dnZXIuZGVidWcoYGV4ZWN1dGUoKSBbbmFtZToke3BlbmRpbmdUYXNrLm5hbWV9XWApO1xuICAgICAgICBpZiAocGVuZGluZ1Rhc2suZXhlY3V0ZWRBdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nVGFzay5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBlbmRpbmdUYXNrLnRhc2soKTtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHRhc2sgd2l0aCBpdHMgcmVzb2x2ZWQgcmVzdWx0IChpZiBhbnkpLlxuICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmVqZWN0IHRoZSB0YXNrIHdpdGggaXRzIHJlamVjdGVkIGVycm9yLlxuICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXdhaXRRdWV1ZSA9IEF3YWl0UXVldWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/awaitqueue/lib/index.js\n");

/***/ })

};
;